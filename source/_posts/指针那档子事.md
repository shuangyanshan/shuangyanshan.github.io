---
title: 指针那档子事
date: 2024-04-26 23:20:59
description: 记录一下。
index_img:
tags: c/c++
categories: knowledge
hide: true
archive:
---

```
#include <stdio.h>

//可以先记住一件事情：在定义时，除变量名外的任何标示都是在对该变量类型的阐述。比如说int，int()，int*， int[], int*() ,int*[], int(*)[]……

void main(){
    int* p0 = NULL;         //一枚普普通通的指向（获取并存储）int类型数据的地址的指针变量。
    int **p00 = NULL;       //指向楼上的指针变量的指针。
    int ***p000 = NULL;     //指向楼上的指针变量的指针。
    int ****p0000 = NULL;   //……不是，你最多能达到多少级啊？？？（看编译器吧……）


    //* 关于数组与指针
    /*对于一个type类型数组array[n],

   对array，其是本数组的名，存储该数组首元素的地址（虽然它是个铁打的常量，不是变量，但某种意义上也是个常量指针了……）。如果想以整个数组的长度为被传指针的一个移动单位，得&array。
    对n，
    定义时n代表其具有多少个type类型下的“格子”；
    调用时s[i]代表相对于原本指向这串数据的首地址，我们现在调用的数据之位究竟偏移了多少（所以首位才是s[0]）；
    解引用:*p. &与*是相反的操作。&*p==*&p==p==*&*&……*&p（谁没事这么写啊喂）；
    对多维数组，上文规则依旧适用。则：
    如s[2][3],有两层，
    第一层数组：
    地址：s+i；
    存储：第二层数组（的地址（格子就那么大总不能把数组全塞进去吧？而且还要考虑调用与统一的问题））。
    调用：*(s+i)==s[i]，s[i]是第二层的名……恭喜你，获得了第二层数组分数组的地址！
    第二层数组：
    地址：&s[i][j]==s[i]+j==*(s+i)+j;
    调用：s[i][j]==*(s[i]+j)=*(*(s+i)+j);
    之后同理。
    ……等等，觉不觉得地址解包还是地址有点眼熟？**p啊！
    除了数组，指针途径还有结构体等（到目前为止想不到了）途径可以实现。
    说到结构体，提及一个指针引用表示方法：struct a{struct a* b;int c}*pa;pa->c,*(pa->b),……
    */


    int* p[3] = {NULL};       //指针数组。存int类型数据的地址的数组
    int (*p1)[3] = NULL;     //数组指针，此处指向2维数组;p本身可以在一层偏移（隐层，或者说“房间”。房间的个数即我们规定的3），其本身默认所指又归属于了从上往下数的第一层;[3]表示p指向的存在有三层（显层），通过使p一次性偏移3*k个int数据长度来实现跨层（k为不为0的整数）
    int (*p2)[2][2] = NULL; //让我们来做个实验。



    int* fun(int,int);      //指针函数，返回值为某类型的地址的函数；
    int (*pfun)(int);       //函数指针，pfun指向以一个int类型为唯一参量的函数；
    int (*s[4])(int);       
    //1. 指针数组，存的是某类型的地址；2. 见（int），这地址是函数的地址；返回值类型为int；3. 这是存特定函数地址的数组。（具体是什么函数自己分析）
    /*或者，1. 见（int），肯定跟函数有关；类型为int，把括号当整体，是返回值为int类型的函数；
    2. 括号内，它先是个数组，然后存了地址（是个指针），结合之前分析，这个数组内元素是特定函数的地址；
    3. 所以这玩意是个指向特定参数函数的指针数组*/
    int* (*s1[4])(int);  
    //分析同上，但这玩意指向的函数返回值为int*类型。  




    int a[][3] = {1,2,3,4,5,6,7,8,9};
    int b[3] = {10,11,12};
    //试试传内部数组
    p1 = a[1]; //警告了。原因：我们规定了p的移动单位为3个元素的长度;a[1]是数组的地址，*a[1]是array首元素的地址。
    printf("%d %d;%d %d;%d %d",**p1,a[1][0],*(p1+1),&a[1][1],*p1,a[1]);
    //尝试三维数组
    int c[2][2][2] = {{{1,1},{1,2}},{{2,1},{2,2}}};
    printf("%d,%d",c[0][0][0],c[1][0][1]);
    p2 = c;
    printf("%d,%d",*(*(*(p2+1)+1)+1),c[1][0][1]);
    //emmm貌似还有逻辑要盘。贴个链接挖个坑。https://www.zhihu.com/question/537092719

}
```
