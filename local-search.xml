<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c的一些问题</title>
    <link href="/2024/04/28/c%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/28/c%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="实现输入整型数据串后敲回车结束输入">实现输入整型数据串后敲回车结束输入</h3><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>* p=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br><br>    p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(p,n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;;i++)&#123;<br>        p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(p,(++n)*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p+i);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getchar</span>()==<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//可能是因为scanf在读取时会自动跳过空格读取下一个数+scanf读取完后顺位的空格or回车被getchar读取。综合下来实现了只要敲回车就能输入数据的功能。</span><br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  &quot;</span>,*(p+i));<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ardunio</title>
    <link href="/2024/04/27/arduino/"/>
    <url>/2024/04/27/arduino/</url>
    
    <content type="html"><![CDATA[<h1 id="把用户文件夹改了名之后发现arduino崩了只能用管理员权限运行老是在创建原用户文件夹怎么办">把用户文件夹改了名之后发现arduino崩了/只能用管理员权限运行/老是在创建原用户文件夹怎么办？</h1><p>答：</p><ol type="1"><li><p>确保你删得干干净净，连隐藏文件都被你删了（没错就是appdata中的.arduinoIDE文件夹）（推测，待验证）</p></li><li><p>将上面提及的文件夹点开，把arduino—cli.yaml文件中的路径中的原用户名全部改成现在的用户文件夹名。然后重启软件。</p></li></ol><p><em>.arduinoIDE文件夹是</em></p>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指针那档子事</title>
    <link href="/2024/04/26/%E6%8C%87%E9%92%88%E9%82%A3%E6%A1%A3%E5%AD%90%E4%BA%8B/"/>
    <url>/2024/04/26/%E6%8C%87%E9%92%88%E9%82%A3%E6%A1%A3%E5%AD%90%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include &lt;stdio.h&gt;<br><br>//可以先记住一件事情：在定义时，除变量名外的任何标示都是在对该变量类型的阐述。比如说int，int()，int*， int<span class="hljs-comment">[]</span>, int*() ,int*<span class="hljs-comment">[]</span>, int(*)<span class="hljs-comment">[]</span>……<br><br>void main()&#123;<br>    int* p0 = NULL;         //一枚普普通通的指向（获取并存储）int类型数据的地址的指针变量。<br>    int **p00 = NULL;       //指向楼上的指针变量的指针。<br>    int ***p000 = NULL;     //指向楼上的指针变量的指针。<br>    int ****p0000 = NULL;   //……不是，你最多能达到多少级啊？？？（看编译器吧……）<br><br><br>    //* 关于数组与指针<br>    /*对于一个type类型数组array<span class="hljs-comment">[n]</span>,<br><br>   对array，其是本数组的名，存储该数组首元素的地址（虽然它是个铁打的常量，不是变量，但某种意义上也是个常量指针了……）。如果想以整个数组的长度为被传指针的一个移动单位，得&amp;array。<br>    对n，<br>    定义时n代表其具有多少个type类型下的“格子”；<br>    调用时s<span class="hljs-comment">[i]</span>代表相对于原本指向这串数据的首地址，我们现在调用的数据之位究竟偏移了多少（所以首位才是s<span class="hljs-comment">[0]</span>）；<br>    解引用:*p. &amp;与*是相反的操作。&amp;*p==*&amp;p==p==*&amp;*&amp;……*&amp;p（谁没事这么写啊喂）；<br>    对多维数组，上文规则依旧适用。则：<br>    如s<span class="hljs-comment">[2]</span><span class="hljs-comment">[3]</span>,有两层，<br>    第一层数组：<br>    地址：s+i；<br>    存储：第二层数组（的地址（格子就那么大总不能把数组全塞进去吧？而且还要考虑调用与统一的问题））。<br>    调用：*(s+i)==s<span class="hljs-comment">[i]</span>，s<span class="hljs-comment">[i]</span>是第二层的名……恭喜你，获得了第二层数组分数组的地址！<br>    第二层数组：<br>    地址：&amp;s<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>==s<span class="hljs-comment">[i]</span>+j==*(s+i)+j;<br>    调用：s<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>==*(s<span class="hljs-comment">[i]</span>+j)=*(*(s+i)+j);<br>    之后同理。<br>    ……等等，觉不觉得地址解包还是地址有点眼熟？**p啊！<br>    除了数组，指针途径还有结构体等（到目前为止想不到了）途径可以实现。<br>    说到结构体，提及一个指针引用表示方法：struct a&#123;struct a* b;int c&#125;*pa;pa-&gt;c,*(pa-&gt;b),……<br>    */<br><br><br>    int* p<span class="hljs-comment">[3]</span> = &#123;NULL&#125;;       //指针数组。存int类型数据的地址的数组<br>    int (*p1)<span class="hljs-comment">[3]</span> = NULL;     //数组指针，此处指向2维数组;p本身可以在一层偏移（隐层，或者说“房间”。房间的个数即我们规定的3），其本身默认所指又归属于了从上往下数的第一层;<span class="hljs-comment">[3]</span>表示p指向的存在有三层（显层），通过使p一次性偏移3*k个int数据长度来实现跨层（k为不为0的整数）<br>    int (*p2)<span class="hljs-comment">[2]</span><span class="hljs-comment">[2]</span> = NULL; //让我们来做个实验。<br><br><br><br>    int* fun(int,int);      //指针函数，返回值为某类型的地址的函数；<br>    int (*pfun)(int);       //函数指针，pfun指向以一个int类型为唯一参量的函数；<br>    int (*s<span class="hljs-comment">[4]</span>)(int);       <br>    //1. 指针数组，存的是某类型的地址；2. 见（int），这地址是函数的地址；返回值类型为int；3. 这是存特定函数地址的数组。（具体是什么函数自己分析）<br>    /*或者，1. 见（int），肯定跟函数有关；类型为int，把括号当整体，是返回值为int类型的函数；<br>    2. 括号内，它先是个数组，然后存了地址（是个指针），结合之前分析，这个数组内元素是特定函数的地址；<br>    3. 所以这玩意是个指向特定参数函数的指针数组*/<br>    int* (*s1<span class="hljs-comment">[4]</span>)(int);  <br>    //分析同上，但这玩意指向的函数返回值为int*类型。  <br><br><br><br><br>    int a<span class="hljs-comment">[]</span><span class="hljs-comment">[3]</span> = &#123;1,2,3,4,5,6,7,8,9&#125;;<br>    int b<span class="hljs-comment">[3]</span> = &#123;10,11,12&#125;;<br>    //试试传内部数组<br>    p1 = a<span class="hljs-comment">[1]</span>; //警告了。原因：我们规定了p的移动单位为3个元素的长度;a<span class="hljs-comment">[1]</span>是数组的地址，*a<span class="hljs-comment">[1]</span>是array首元素的地址。<br>    printf(<span class="hljs-string">&quot;%d %d;%d %d;%d %d&quot;</span>,**p1,a<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span>,*(p1+1),&amp;a<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span>,*p1,a<span class="hljs-comment">[1]</span>);<br>    //尝试三维数组<br>    int c<span class="hljs-comment">[2]</span><span class="hljs-comment">[2]</span><span class="hljs-comment">[2]</span> = &#123;&#123;&#123;1,1&#125;,&#123;1,2&#125;&#125;,&#123;&#123;2,1&#125;,&#123;2,2&#125;&#125;&#125;;<br>    printf(<span class="hljs-string">&quot;%d,%d&quot;</span>,c<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>,c<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span>);<br>    p2 = c;<br>    printf(<span class="hljs-string">&quot;%d,%d&quot;</span>,*(*(*(p2+1)+1)+1),c<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span>);<br>    //emmm貌似还有逻辑要盘。贴个链接挖个坑。https://www.zhihu.com/question/537092719<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>气体动理论与热力学相关</title>
    <link href="/2024/04/22/%E5%A4%A7%E7%89%A9%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/04/22/%E5%A4%A7%E7%89%A9%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p style="color:#808080"><i>上课的时候卡在概率函数后相关知识的进度就大雪崩了……所以理理（欠的债总归是要还的T_T）。</i></p>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线代的一些解惑</title>
    <link href="/2024/04/22/%E7%BA%BF%E4%BB%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E6%83%91/"/>
    <url>/2024/04/22/%E7%BA%BF%E4%BB%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E6%83%91/</url>
    
    <content type="html"><![CDATA[<p style="color:#808080"><i> 记录一下，免得总是忘而又推。</i></p><ul><li><p>列向量组求解极大无关组为什么必须用行变换？</p><p>准确地来说是通过研究列向量组的<span class="math inline">\(k_i\)</span>的值来求解极大无关组时限定用行变换（行向量组则为列变换。）</p><p>在求解极大无关组（以下简称“极无”）时，我们得先判断向量组的相关性——或者说，<span class="math inline">\(Ak=0\)</span>时<span class="math inline">\(k_i\)</span>的取值。进而，查看<span class="math inline">\(|A|\)</span>或<span class="math inline">\(R(A)\)</span>的的取值。<strong>此时我们必须明确一点：我们在研究<span class="math inline">\(k_i\)</span>。</strong></p><p>于是我们可以列出一个方程组： <span class="math display">\[k_1\alpha_1+k_2\alpha_2+\cdots+k_n\alpha_n=0\]</span>展开为： <span class="math display">\[k_1\begin{bmatrix}a_{11}\\\vdots\\a_{1r}\end{bmatrix}+k_2\begin{bmatrix}a_{21}\\\vdots\\a_{2r}\end{bmatrix}+\cdots+k_n\begin{bmatrix}a_{n1}\\\vdots\\a_{nr}\end{bmatrix}=0\]</span></p><p>即 <span class="math display">\[\begin{bmatrix}a_{11}&amp;\cdots&amp;a_{n1}\\\vdots&amp;\ddots&amp;\vdots \\a_{1r}&amp;\cdots&amp;a_{nr}\end{bmatrix}  \begin{bmatrix}k_1\\\vdots\\k_r\end{bmatrix}=0\]</span></p><p>其中，<span class="math inline">\(a_{ij}\)</span>为<span class="math inline">\(k_i\)</span>的系数；每一行的式子必须同时满足。</p><p>明显，直接这么看<span class="math inline">\(a_{ij}\)</span>很难看出什么。于是我们可以让<span class="math inline">\(k_i\)</span>的系数唯一表示，而这就代表我们需要行变换将其——至少其中的几个——的系数唯一化（行阶梯型乃至行最简型）。</p><p>为直观表示，我们取,r = n = 3.于是我们可得 <span class="math display">\[\begin{bmatrix}  1&amp;&amp;b_1\\  &amp;1&amp;b_2\\  &amp;&amp;b_3\\  \end{bmatrix}\]</span>1的分布不必像上面那样排列得那么规整（不过此时要注意对应的是哪个列向量）。</p><p>于是，<br>当<span class="math inline">\(\alpha_i\)</span>线性无关时,必可得<span class="math inline">\(b_3\neq0,b_1=b_2=0\)</span>;<br>线性相关时，必有<span class="math inline">\(b_3 = 0\)</span>.</p><p>此时,对<span class="math inline">\(\alpha_i\)</span>，视<span class="math inline">\(\alpha_1\)</span>与<span class="math inline">\(\alpha_2\)</span>为基向量，由初等变换的等价性与向量表示的形式不变性可知<span class="math display">\[b_1\alpha_1+b_1\alpha_2=\alpha_3\]</span>于是，我们通过将列向量组进行行变换得出的行最简型同时得到了其的一组极大无关组和以极无为基底表示的其他向量。</p><p>行向量组同理。</p><p><span class="math inline">\(Q.E.D\)</span></p><hr></li><li><p>基础解系是怎么来的？</p><ol type="1"><li><p><span class="math inline">\(Ak=0\)</span>:</p><p>还记得上文<span class="math inline">\(Ak=0\)</span>的吗？当<span class="math inline">\(r&lt;n\)</span>时，设<span class="math inline">\(R(A) = a\)</span>,经行变换至行最简型，必有<span class="math inline">\(n-a\)</span>个自由未知量。由Cramer法则可知当自由未知量的值确定了，被约束量也会被唯一确定。</p><p>于是依次取一组自由未知量（使得到的向量组线性无关，优先考虑每次只取1，其他为0），算得约束量的结果，两者拼起来即为一个解向量。于是我们可以得到<span class="math inline">\(n-r\)</span>个解向量，且由“向量之间若线性无关，加维度依旧无关；若线性相关，减维度依旧相关”可知解向量之间线性无关。</p><p>最终,我们便这么得到了一组基础解系。</p><p>（其实本来还有0向量，但我们只要把系数取0即可得到它了，所以0向量在这个基础解系面前就不特殊了）。</p><p>（emmm但怎么证这么表示是涵盖全部解的……）</p></li><li><p><span class="math inline">\(Ax = b\)</span>:</p><p>对方程组进行同样的操作，不同的是接着我们先把自由未知量全部取0，此时<span class="math inline">\(\begin{pmatrix}b^T\quad 0&amp;\cdots&amp;0\end{pmatrix}^T\)</span>即为方程组的一特解。</p><p>然后我们把<span class="math inline">\(Ax =0\)</span>的通解一加就能得到<span class="math inline">\(Ax =b\)</span>的通解啦！</p><p>（易证1.中的解向量与<span class="math inline">\(b&#39;\)</span>线性无关）</p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blender部分操作</title>
    <link href="/2024/03/30/blender%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/03/30/blender%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p style="color:rgb(214,160,29)"><i>本博客在此知乎专栏<a href="https://zhuanlan.zhihu.com/p/628501434">Blender操作笔记——基本操作</a>的基础上改动而成</i></p><p>更新：发现了个自认为归纳得更好的<a href="https://zhuanlan.zhihu.com/p/126650481">【Blender】快捷键大全（超级详细，应有尽有，不断更新）</a></p><h1 id="快捷键与操作解释">快捷键与操作解释</h1><ol type="1"><li><h2 id="常用操作">常用操作</h2><ol type="1"><li><p>游标与选中项吸附功能：shift+S</p></li><li><p>创建：shift+a</p></li><li><p>复制移动：shift+d（此时按esc可使其回到原位置；ifesc后点到鼠标使选中区消失，则鼠标移动到该区域按l？）</p></li><li><p>分离图层：p</p></li><li><p>框选：b</p></li><li><p>反选：ctrl+l</p></li><li><p>进入编辑模式：tab</p></li><li><p>重复上一步操作：shift+r</p></li><li><p>选中循环边，alt+左键选一条边选中后在面那边按栅格填充可以填充面，原理在下面选中一个点，然后按f，最后选另一个点可连线选中一边的点后可以拉伸而不改变选中区域的长宽高选中两个点，然后按f，可连线，边则连面点模式挤出圈圈后右键合并顶点到中心可以这样，此时用i插入循环边</p></li><li><p>删除：x</p></li><li><p>透视：alt+z*（配合平面图时可以选中区域内被遮挡的部分）</p></li><li><p>隐藏：H隐藏=关闭小眼睛的操作，alt+h开启=打开小眼睛</p></li><li><p>物体镜像：镜像是基于原点的，ctrl+m进入到交互镜像，按X/Y/Z分别在对应轴镜像，或者按住鼠标中键，指定轴快速切换到对应轴上；</p></li><li><p>父子集设置：选中要绑定的对象，ctrl+P，最后选择的活动项为父级。设置父子集目标-物体：子集随着父集变换，子集可以单独变换，变换子集不影响父集；</p></li><li><p>调整父子集关系：按住shift，直接拖动物体到父集上，或者把子集物体拖出来；</p></li><li><p>进入第一人称观察模式：shift+~，w是前进，s是后退，a是左移，d是右移，q是下降，e是抬升，shift加速，alt减速；</p></li><li><p>以某个物体为准心：选中某个物体，按空格键就是以该物体为准心，可以直接去到该物体，右键可退出；</p></li><li><p>打开禁用：右上角限制开关-点上小电脑和小相机图标，小电脑是在视图中禁用，小相机是在渲染中禁用</p></li><li></li></ol></li><li><h2 id="视图查看">视图/查看</h2><ol type="1"><li>小键盘不开“numlk”时的数字：切换视角<ol type="1"><li>1,进入前视图 3，右视图 7，左视图 9，顶视图 Ctrl+1后视图 之后的同理。移动鼠标即可回到三维视角</li><li>ctrl+alt+Q：进入到四视图视角</li><li>ctrl+alt+0（小键盘的0）：设置当前视角为相机视角。n键调出侧边栏之后，视图-☑️锁定相机到视图，即可随意调整摄像机中的物体视图位置，调整完之后取消勾选；</li><li>~：可调出各个视图的选择</li></ol></li></ol></li><li><h2 id="左边栏基础工具">左边栏基础工具</h2><ul><li><p>G：移动，alt+G：移动归零，G+X/YZ：对应的X/Y/Z轴移动；</p></li><li><p>R：旋转，alt+R：旋转角度归零，R+X/YZ：对应的X/Y/Z轴旋转，R+X+45：沿着X轴旋转45度；</p></li><li><p>S：缩放，S+X/YZ：对应的X/Y/Z轴缩放，S+X+5：沿着X轴缩放5倍；</p></li><li><p>法向缩放：alt+s（和s对比一下吧…）</p></li><li><p>加选：ctrl+左键</p></li><li><p>w：选择工具切换</p></li><li><p>a：全选；a+a：取消全选；</p></li><li><p>x：删除；</p></li></ul></li><li><h2 id="窗口">窗口</h2><ul><li><p>增加视图窗口：鼠标移动到最右侧，右键-垂直分割；</p></li><li><p>取消新增的视图窗口：鼠标移动到两个窗口中间的线，右键-合并区域，选择向左或向右的箭头即可向左或向右合并；(如果出现鼠标移动到边线上未出现加号，可能是设置-界面中的拐角拆分没有勾选)</p></li><li><p>新建窗口，"窗口/layout"处</p></li><li><p>ctrl+空格：窗口最大化</p></li><li><p>ctrl+alt+空格：全屏</p></li></ul></li><li><h2 id="坐标系">坐标系</h2><ol type="1"><li><p>局部坐标系：以自身物体为轴心的坐标系</p></li><li><p>法向坐标系：在编辑模式下，选中某个面，是以面的方向为轴心</p></li><li><p>万向坐标系：通过固定两个轴的方向，旋转第三个轴。在变换选项中，模式XYZ：Y轴是旋转轴，Z轴是转向轴；</p></li><li><p>视图坐标系：坐标轴会永远以当前的观察者视窗为坐标系</p></li><li><p>新建坐标系：选中哪个物体，新建的坐标系就以哪个物体为主</p></li><li><p>游标坐标系：以游标为主的坐标系</p></li><li><p>,（英文的逗号键）：调出坐标系图</p></li></ol></li><li><h2 id="变换轴心点工具">变换轴心点工具</h2><ol type="1"><li><p>.（英文的句号键）：调出变换轴心点快速切换图</p></li><li><p>选项-原点：勾上原点，可单独编辑原点</p></li><li><p>原点回到几何中心：右键-设置原点-原点&gt;几何中心</p></li><li><p>原点&gt;质心，可以根据体积或表面积计算</p></li><li><p>以边界框中心为轴心：物体的框的中心就是边界框中心</p></li><li><p>以各自的原点为轴心：即多个几何体，每个几何体都沿着自己的原点缩放/移动/旋转</p></li><li><p>以活动物体为轴心：即以最后选定的物体为轴心</p></li></ol></li><li><h2 id="吸附工具">吸附工具</h2><ol type="1"><li>开启/关闭吸附工具：shift+tab，或者直接点击吸附图标；</li><li>临时开启/关闭：选中物体时按下ctrl</li><li>吸附至-顶点/面/边：是相对于被吸附对象而言的，A被吸附至B的顶点/面/边，把某一物体放到另一物体上面</li><li>吸附至-增量：移动的时候是以吸附体的为单位移动的</li><li>吸附至-顶点：可选择以质心/中心/活动项为基准点</li><li>吸附至-体积：模型A快速准确装入模型B</li></ol></li><li><h2 id="衰减编辑">衰减编辑</h2><ol type="1"><li><p>开启/关闭吸附工具：o在编辑模式下，衰减工具可以辅助建模，拉出需要的形状</p></li><li><p>仅相连项：勾选以后，两个物体，只对其中一个操作</p></li><li><p>从视角投影：开启后编辑左/右/前/后视图时，只对单个视图起作用</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电路原理相关</title>
    <link href="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<!-- <style type="text/css">.post-toc .nav .nav-level-1>.nav-child {   display: block;}</style> --><h1 id="前置知识">前置知识</h1><h3 id="集总电路">集总电路</h3><ul><li><p>元件的特点</p></li><li><p>集总电路的定义及分类</p></li></ul><h3 id="参考方向与实际方向">参考方向与实际方向</h3><h3 id="电路分析的对象">电路分析的对象</h3><ul><li><p>电流 直流（DC）与交流（AC） 参考方向</p></li><li><p>电压 参考极性</p></li><li><p>功率 意义：能量流动的速率。 方向：能量流动（传输)的方向；</p><p><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/Snipaste_2024-04-20_15-05-59.png" title alt style="zoom:80%;">明确：基于能量守恒，提供与吸收在指定某个方向的前提下，绝对值相等，正负号相反。</p><p>参考方向：电流流动与电压降的方向相同；计算方法：查看电流与电压降的方向关系，若是关联则正常列出，不关联则添个负号，以保证我们始终以参考方向为列式基准。相对于参考方向，当功率的实际方向与参考方向相同时<em>(在计算中体现为结果为负）</em>，功率为正（此时能量流经的该部分吸收能量），反之为负（此时被称为“提供的功率”)。</p></li></ul><h3 id="关于si单位的倍数单位">关于SI单位的倍数单位</h3><p><img title src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/Snipaste_2024-04-20_15-05-54.png" alt style="zoom:80%;"></p><h3 id="电路的一些概念">电路的一些概念</h3><ol type="1"><li><p>回路</p></li><li><p>节点（与超节点）一个元件的两端即是一个。同在一条支路的元件可合并为一个含n个节点的电路有n-1个独立回路（能提供独立kcl方程的节点）。（如果遇到电阻串电压+使用节点分析，多设一个在两者之间的节点。）</p></li><li><p>网孔（注意只要轮廓线闭合即可）一个n+1孔（含最外围）电路中有n个独立网孔（能提供独立kvl方程的回路）。</p></li><li><p>有源、无源与含源：有源与无源可依据二端电阻能否向外电路提供能量来判定（如负电阻与电压源为有源元件）；“含源“则是</p></li><li><p>记忆性 <img src> 无记忆性意味着什么：</p></li></ol><h1 id="各种元件介绍">各种元件介绍</h1><p style="color:#808080"><i>以下若不标注，皆默认为理想状态。<br>没必要按顺序看，哪个不太清楚了再查。</i></p><p style="color:＃FF8C00"><i>理想状态：只确定具有一种功能（特性），其他特性皆为该功能成立的延伸。如果讨论，能直接使用的皆只有该功能。</i></p><h3 id="电阻与电导">电阻（与电导）</h3><p>只反映电阻器对电流呈现阻力的性能。</p><p><img title src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/电阻.png" alt style="zoom:80%;"></p><p>分为线性（遵循欧姆定律）与非线性；时变与时不变。皆无记忆性。电导即为电阻的倒数，单位为S（西门子）。电阻功率：至少在本书范围，因R永不小于0，其功率永为正（吸收）。 <span class="math display">\[p(t) = Ri^2(t) = \frac{i^2(t)}{G}\]</span> <span class="math display">\[ p(t) =  \frac{u^2(t)}{R}=Gu^2(t) \]</span>等效电阻/电导：</p><h3 id="独立源激励源">独立源（激励源）</h3><ol type="1"><li><p>电压源：两端永远保持一定电压而不论流过其的电流为多少（负的——如果有负的——也行），导致其既可提供又可吸收能量。与电压源并联的元件，其电压即为电压源的电压。推论但做题的时候不能直接用否则容易翻车：理想电压源的内阻为0.</p></li><li><p>理想电流源：不论两端电压为多少（意味着其电压存在且不定），永远向外电路提供一定电流的元件。与电流源串联的元件，其电流即为电流源的电流。推论但做题的时候不能直接用否则容易翻车：理想电流源的内阻为<span class="math inline">\(\infty\)</span>。</p></li></ol><h3 id="受控源">受控源</h3><p>是为了便于电路分析而抽象出来的模型；一种受控源可以对应多个电路，并非一个。每一个内部电路原理是不同的。</p><ol type="1"><li><p>压控电压源，压控电流源，流控电压源，流控电流源</p></li><li><p>在解题时：</p><ol type="1"><li>可以将其看作是独立源来列kcl、kvl(回路与节点法)，但绝不能真将其视为独立源（地位与电阻类似）（回路、节点以外的任何方法）</li><li>一定要注意激励的存在与否，采取的解题方法会不会将激励嘎了。</li></ol></li></ol><h3 id="二极管">二极管</h3><h3 id="运算放大器">运算放大器</h3><h3 id="三极管">三极管</h3><h3 id="电容">电容</h3><h3 id="电导">电导</h3><h1 id="电路的表示">电路的表示</h1><p><img title src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/电路的习惯表示.png" alt style="zoom:80%;"></p><p>在求解的时候将上图电路化为网络形式。</p><h1 id="各种定律">各种定律</h1><p>法则：电荷守恒与能量守恒——</p><h3 id="公理">公理</h3><ol type="1"><li><p>kcl与kvl</p><p><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/Snipaste_2024-04-20_15-15-53.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/kvl.png" title alt style="zoom:80%;"></p></li></ol><h3 id="其他">其他</h3><h4 id="网络函数">网络函数</h4><p>线性电路的比例性（于是我们可以通过设数与电路激励与响应之间的比例关系求解问题）</p><p><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/网络函数_题.png" title alt="网络函数_题" style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/网络函数.png" title alt style="zoom:80%;"></p><h4 id="置换定理">置换定理</h4><p>一种基于工作点相同的”等效“替换。<img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/置换定理.png" title alt style="zoom:80%;"></p><h1 id="分析方法">分析方法</h1><p><strong><em>当我们开始求解的时候，我们应该先看看各部分支路的电阻电流电压（单元件或多元件/整个支路两端）关系，从而能够少设点未知量、少设点关系方程并更快地求出所需的未知量等等。并且，在求的过程中注意能不能直接使用所需未知量来列写方程，回路之间的关系、一些错误思维惯性也要注意到。（见附录）</em></strong></p><h3 id="网孔与节点">网孔与节点</h3><p>（原理：kvl/kcl）（内部列完了从外部补缺失的！）</p><p>（可能需要补充方程）</p><p>如遇受控源，要么设未知要么来个超网孔/超节点绕过去。</p><p>超xx在无受控源的情况下也适用,用的时候要注意这并不意味着我们直接将该节点看作为拥有一个节点电压<span class="math inline">\(u^{&#39;}\)</span>;我们列的是kcl,原各节点的电压还是绕不开的。<del>（本人就是这么翻车的）</del></p><p><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/kcl_and_kvl.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/网孔分析.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/节点法_题.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/节点法_题1.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/节点法_题2.png" title alt style="zoom:80%;"></p><h3 id="网络函数与叠加">网络函数与叠加</h3><p>原理：电场叠加原理、基尔霍夫定律与……</p><p>注意：</p><ol type="1"><li><p>运用叠加原理时可以留下多个独立源，剩下的独立源视为零值；受控源与电阻应被同样对待。</p></li><li><p>不能用叠加方法求分功率然后相加，容易翻车。</p></li></ol><p><em>网络函数</em><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/网络函数.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/网络函数_题.png" title alt style="zoom:80%;"></p><p><em>叠加原理</em></p><p>适用范围：线性电路（电阻，电感，电容等）；</p><p>独立源单独作用，受控源保持不变。</p><p>不用叠加来求功率！<img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/叠加原理.png" title alt style="zoom:100%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/叠加原理_题.png" title alt style="zoom:100%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/叠加原理_题1.png" title alt style="zoom:100%;"></p><p>齐性定理： 即方程的齐次性；系数成比例变化。</p><h3 id="分解与变换">分解与变换</h3><h4 id="原理">原理</h4><ol type="1"><li><p>我们往往只需要单口网络的vcr而不是单个元件的VCR（即我们对黑箱子内的构造并不关心）；</p></li><li><p>一个元件的u-i关系由元件本身所确定，与外界电路无关；同样，<strong>若一个单口网络除了通过它的两个端钮与外界相连结外，别无其他关系的话，其VCR也是由该端口网络本身所确定</strong>。因此，此时可以在任何外界电路的情况下来求解其VCR。（于是，我们完全可以将外界电路换成最简单的来进行替代，从而求出单口网络的u-i关系；反过来想，只要<strong>u-i关系一致</strong>，我们完全可以用<strong>等效</strong>最简电路来替换单口网络，从而对原电路的另一端来说从未改变；再进一步，只要电路两部分的ui关系曲线相交于同一点（<strong>相同工作点</strong>），我们完全可以进行<strong>置换</strong>。（就是这样极大概率被限制于那一点了）（图见”置换定理“））</p></li></ol><h4 id="单口网络">单口网络</h4><h5 id="vcr求法">VCR求法</h5><p>外施电流求电压/外施电压求电流法，从而解得ui关系。</p><p>（可以看看该网络用方法求解比较简单来确定是定电流源还是电压源。如果网孔最好用电压源；如果节点倾向于电流源）</p><p>注意:解的时候不要纠结于缺了一个方程而解不出来——我们要的是关系而不是确定解！！！（当然，如果缺了2个及以上的话就该纠结了）</p><h5 id="等效电路">等效电路</h5><p>VCR相同。</p><p>由于网络划分的随意性及内外部网络的影响性质，可以嵌套等效；但相对位置不能乱，毕竟要保证电路的结构“不变”，如两电流源支路之间有一个串联的电阻时，不·准·合·并·电·流·源！！！</p><p>类型： (以下如未标明，皆为独立)</p><p>对纯电阻电路：可等效为仅含一个电阻的电路。</p><p>电阻+受控源：同上。不过可能会得到负值电阻。</p><p><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/等效电路_电阻+受控源.png" title alt style="zoom:80%;"></p><p>电压源串联:</p><p>电流源并联：</p><p>电阻串联：</p><p>电阻并联：</p><p>流与压/阻串联：电流是绝对量，从电压视角，麻烦，压/阻”多余“；</p><p>压与流/阻并联：电压是绝对量，从电流视角，麻烦，流/阻”多余“。</p><p>有伴电压源与有伴电流源的互化： <span class="math display">\[u_1 =i_2R\]</span> <span class="math display">\[i_2=Gu_1\]</span> <img src></p><h5 id="戴维南与诺顿">戴维南与诺顿</h5><p>适用电路：一般的（R不为无穷）、线性的、单口/二端网络。<img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/戴维南定理.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/戴维南1.png"> <img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/戴维南2.png"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/诺顿.png" title alt style="zoom:80%;"><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/诺顿都存在意义.png" title alt style="zoom:80%;"></p><p>注意，我们讨论的对象该单口网络，u、i的参考方向的关联与否取决于该单口网络（开口端）而不是外电路。</p><p>求法：</p><ol type="1"><li><p>求<span class="math inline">\(u_{oc}\)</span>、<span class="math inline">\(i_{sc}\)</span>：</p><ul><li><strong>叠加法</strong>分着求（记得最后加起来）</li><li><strong>断路/短路法</strong>直接求。（对于受控源，如果其控制量在端口处，并且为电压，短接万岁！）</li></ul></li><li><p>求<span class="math inline">\(R_o\)</span>：</p><ol type="1"><li>将单口网络独立源或短路、或短路后直接求<span class="math inline">\(R_o\)</span>,或用外施电源法求<span class="math inline">\(R_o\)</span>。</li></ol><p>（如果内部存在受控源，只能用此方法；可能会求出负电阻。）</p><ol start="2" type="1"><li>开路短路法：<span class="math inline">\(R_o=\frac{u_{oc}}{i_{sc}}\)</span></li></ol></li></ol><p>注意：</p><ul><li>从全面求解分解方式是随意的，怎么方便怎么划；但</li><li>戴维南与诺顿从叠加原理推出，注意事项参见”网络函数与叠加“；</li><li>对受控源，地位同电阻，且一定要注意控制端有没有被我们嘎掉！！（如果控制端为单口网络的开口处电流与电压或在其内部，那没事了）<ul><li>如果电路中线性与非线性混合，可以试着将其划分为两部分，再联立/由图可知解得。</li><li>叠加方法可使多个激励或复杂激励电路的求解问题化为简单激励电路的求解问题，仅限于线性电路，而分解方法将结构复杂化为结构简单，通用（分而解之）。</li></ul></li></ul><h4 id="二端网络之互易定理">二端网络之互易定理</h4><ul><li><p>双口网络的研究（具体看书吧……）：</p><pre><code class="hljs">依据线性电路的线性特性与激励变量与相应变量之间的叠加关系列出方程组，并通过取0求得相应系数。然后，依据本人暂未想明白的电路关系，得到了一些等量关系（见下图）.加以延伸，得到互易定理：</code></pre></li><li><p>互易定理：</p><pre><code class="hljs"> &lt;img src=&quot;电路原理相关/互易定理.png&quot; title=&quot;&quot; alt=&quot;&quot; style=&quot;zoom:80%;&quot;&gt;来源:线性电阻的双向性如果两端有</code></pre></li></ul><h4 id="三端最简网络之t型与pi型电阻的互化">三端最简网络之<span class="math inline">\(T\)</span>型与<span class="math inline">\(pi\)</span>型电阻的互化</h4><p><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/三端最简型.png" title alt style="zoom:100%;"></p><p>在保证三端的电压/电流皆相同的前提下,使电阻满足下方关系:</p><p><span class="math inline">\(T\)</span>转<span class="math inline">\(pi\)</span>:<img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/三端_T_pi.png" title alt style="zoom:80%;"></p><p><span class="math inline">\(pi转T\)</span>:<img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/三端_pi_T.png" title alt style="zoom:80%;"></p><h1 id="其他-1">其他</h1><h3 id="关于关联参考方向与非关联参考方向">关于关联参考方向与非关联参考方向</h3><p style="color:#808080"><i>做题过程中总是弄混正负号，故还是理一理吧……</i></p><p>我们规定：</p><ul><li><p>关联参考方向为：对某一电路部分（导线，元件，网络……），电流的参考方向与电压降的参考方向一致；</p></li><li><p>非关联参考方向即是相反。</p></li></ul><p>于是，对电路的某一部分(某一元件/网络/……），如果流入其的电流的方向箭头指向电压的”+”极，那么该元件的电压与电流便具有关联参考方向。</p><p>对于功率的计算与判断吸收or放出：</p>先依据i与u的方向关系（定下能量流动方向再）判断是否添负号（关联不添非关联添），<p style="color:#808080">此时我们已经确定了该电路部分吸·收·功·率的正方向</p><p>；然后看看最终结果是否有负号，没有就是正向的能量流动，即吸收功率为正，有则说明该部分提供功率。</p><p><img src="/2024/03/28/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/Snipaste_2024-04-20_14-14-10.png" title alt style="zoom:80%;"><img src> <img src> <img src></p><h3 id="一些思维上的注意事项">一些思维上的注意事项</h3><ol type="1"><li>并联：支路两端的电压分别相等；串联：元件之间的电压呈现“接力”现象。</li><li>外接短路线使某支路短路了，其他支路的电流都改道流到了短接线上，但支路本身如果还有电源的话大概率它自身也“产生”电流，该电流同样会被汇聚于短接线上。</li><li>方法的使用条件。</li><li>网络内部可以嵌套等效，但相对位置不能乱，毕竟要保证电路的结构“不变”。如两电流源支路之间有一个串联的电阻时，不·准·合·并·电·流·源！！！</li></ol><h3 id="计算问题">计算问题</h3><ol type="1"><li>注意正负号。</li><li>注意关联方向。</li><li>注意未知量（不论新设还是本有）的复用。</li><li>注意括号，括号外的系数以及括号内的系数（别再直接把括号外的系数直接当成拆了括号后的系数了！T_T）</li></ol>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>electric</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git相关</title>
    <link href="/2024/03/26/git%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/03/26/git%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍git是什么">1. 介绍——git是什么？</h1><p>首先，先让我们了解一下版本控制系统。</p><span id="more"></span><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。依据参与人数，请让我们将其分为两大类：（个人）本地与可协作——</p><p>本地，顾名思义，just在本地的版本库，修改方便，但若无备份，delete一点，一切白干。</p><p>可协作，分为集中式与分布式。</p><p>在集中式版本控制系统中，版本库集中放在中央服务器。由于修改者一般用的都是自己的电脑（非中央服务器），故工作时，首先要从中央服务器哪里得到最新的文件版本<em>（一般电脑上不会有所有文件的最新版本）</em>，然后再把修改推送到中央服务器。集中式版本控制系统必须联网才能工作，其交互速度受到网速的限制。</p><p>分布式版本控制系统则没有中央服务器，每个人的电脑将存储一个完整的代码仓库（含完整的历史记录），故无须要求联网。当需要多人协作时，合作者之间需要将各自的修改推送给对方，从而起到多人共同修改文件的效果。</p><p>而git，便是当前世界上最先进的分布式版本控制系统。</p><p>版本控制系统的工作原理：</p><p><img src="https://raw.githubusercontent.com/shuangyanshan/image/main/img/%E7%89%88%E6%9C%AC%E5%BA%93%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p><em>Workspace：工作区，添加、编辑、修改文件等操作；</em></p><p><em>Index / Stage：暂存区，暂存已修改的文件；</em></p><p><em>Repository：仓库区（或本地仓库），将index中最终确定的文件保存到仓库成为一个新的版本；</em></p><p><em>Remote：远程仓库</em></p><blockquote><p>图上的操作可以结合下方git常用操作理解</p></blockquote><h1 id="git-的相关操作">2.git 的相关操作</h1><p><a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/30044692">非常说人话的git干货教程1</a></p><p><a href="https://zhuanlan.zhihu.com/p/652125463">教程2（内容其实差不多）</a></p><h2 id="git常用命令">git常用命令：</h2><ul><li><p>git init在已创建目录的前提下将该目录转变为git控制的存储库。</p></li><li><p>git clone 在本地没有版本库时，将远程仓库复制到本地</p></li><li><p>git pull在本地仓库已存在时，从远程仓库拉取（最新的）内容并将其合并到本地版本库中</p></li><li><p>git add 添加文件到暂存区</p></li><li><p>git commit 提交文件到本地仓库</p></li><li><p>git push 将本地仓库的新的改变推送到远程仓库</p></li><li><p>git fetch从远程版本库抓取最新的commits（内容），待用户在检查后决定是否将其合并到工作本机分支中</p></li><li><p>git merge 合并<em>（git pull = git fetch + gitmerge）</em></p></li><li><p>git checkout <branch_name>用于在不同的分支之间切换、恢复文件、创建新分支等操作。</branch_name></p></li></ul><hr><h1 id="一些概念">3.一些概念</h1><h2 id="git数据保存方式">git数据保存方式</h2><p>git在每次进行存储操作时，保存的不是文件的变化或者差异，而是存储的那一时刻的文件快照（可以理解为文件副本，二进制格式存储）。而在我们的本地仓库中，有个.git的隐藏文件夹，这个是git仓库的重要部分，当我们gitinit或者git clone时就会存在，里面objects目录存储所有快照（文件内容）。当你提交一次更新（文件有修改），它就会对当时被修改的文件创建一个快照。</p><p><img src="https://raw.githubusercontent.com/shuangyanshan/image/main/img/59c7c9213bc2433890fb62d9df7ee4fa%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><p>除此之外，git会保存一个提交对象（commitobject），这个提交对象包含了</p><ul><li><p>一个指向暂存内容快照的指针</p></li><li><p>作者的姓名和邮箱</p></li><li><p>提交时输入的信息</p></li><li><p>指向父对象的指针（首次提交操作产生的提交对象中没有父对象） <img src="https://raw.githubusercontent.com/shuangyanshan/image/main/img/769cb13406f14e0e80c238648ae82802%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p></li></ul><p>————T.B.C————</p><h5 id="section"></h5><h2 id="分支">分支</h2><p>一种类似于树及树干形式的对代码所处位置的描述，是代码的可能性。不同分支上的代码可以合并（状态确定）。但合并时可能会出现一些问题（冲突）。</p><p>本质上，分支是不同指针的指向的“迹”。<a href="https://juejin.cn/post/7207263350488907813">git分支图文理解</a></p><h2 id="版本冲突">版本冲突</h2><p>版本冲突多出现在合并操作(合并远程仓库代码或者合并分支代码)中。如果出现版本冲突，需要具体分析出现冲突的代码区，手动进行代码合并，然后再进行提交。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>text1</title>
    <link href="/2024/03/25/text1/"/>
    <url>/2024/03/25/text1/</url>
    
    <content type="html"><![CDATA[<h3 id="测试">测试</h3><h4 id="hhh">hhh</h4><span id="more"></span><hr><p><u>emmm</u></p><p><em>hhh</em></p><p><img src="https://raw.githubusercontent.com/shuangyanshan/image/main/img/942016582!figure_large.jpg"></p>    <div class="fold">      <div class="fold-title fold-info 折叠块的标题 collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>* p=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br>    <br>    p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(p,n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;;i++)&#123;<br>        p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(p,(++n)*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p+i);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getchar</span>()==<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//可能是因为scanf在读取时会自动跳过空格读取下一个数+scanf读取完后顺位的空格or回车被getchar读取。综合下来实现了只要敲回车就能输入数据的功能。</span><br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  &quot;</span>,*(p+i));<br><br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="latex">latex</h1>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
